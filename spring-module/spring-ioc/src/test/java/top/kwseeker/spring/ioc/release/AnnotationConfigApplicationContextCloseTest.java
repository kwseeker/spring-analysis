package top.kwseeker.spring.ioc.release;

import org.junit.Test;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

import java.lang.management.ManagementFactory;

public class AnnotationConfigApplicationContextCloseTest {

    @Test
    public void testConditionalAnnotation() {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        context.start();    //没有这个的话LifecycleBean start() 不会执行, 但是 SmartLifecycle Bean start() 可以自动执行
        OuterBean outerBean = context.getBean("outerBean", OuterBean.class);
        //1内部通过close关闭
        context.close();
    }
    //InnerBean created
    //call OuterBean()...
    //call BeanNameAware setBeanName()...
    //call BeanClassLoaderAware setBeanClassLoader()...
    //call BeanFactoryAware setBeanFactory()...
    //call postProcessBeforeInitialization()...
    //call InitializingBean afterPropertiesSet()...
    //call init()...
    //call postProcessAfterInitialization()...
    //call LifeCycleABean isRunning()...
    //call LifeCycleABean start()...                即在所有其他bean都初始化完成后才执行Lifecycle Bean 的 start() 方法
    //call LifeCycleBBean isRunning()...
    //call LifeCycleBBean start()...
    //...... 退出 ......
    //ContextClosedEvent occurred: 1670384905312
    //call LifeCycleBBean isRunning()...
    //call LifeCycleBBean stop()...
    //call LifeCycleABean isRunning()...
    //call LifeCycleABean stop()...
    //call DisposableBean destroy()...
    //call destroyMethod()...

    @Test
    public void testConditionalAnnotation2() throws InterruptedException {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        //注册关闭钩子
        context.registerShutdownHook();

        OuterBean outerBean = context.getBean("outerBean", OuterBean.class);

        String processName = ManagementFactory.getRuntimeMXBean().getName();
        long pid = Long.parseLong(processName.split("@")[0]);
        System.out.println("进程ID: " + pid);

        //2外部通过信号关闭 (kill -2 <pid> kill -15 <pid>) 通过日志可以看到有回调关闭钩子
        Thread.sleep(100000);
    }
}
